name: Auto-Generate Changelog (Hardened)

on:
  release:
    types: [published]
  workflow_dispatch:

# Prevent concurrent changelog generation to avoid race conditions
concurrency:
  group: changelog-generation
  cancel-in-progress: false

jobs:
  generate-changelog:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Generate Changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import subprocess
          import re
          import sys
          from datetime import datetime
          from collections import defaultdict

          def log_error(context, error, details=None):
              """Structured error logging"""
              print(f"âŒ ERROR in {context}")
              print(f"   Type: {type(error).__name__}")
              print(f"   Message: {str(error)}")
              if details:
                  print(f"   Details: {details}")
              print()

          def get_latest_tag():
              """Get the latest git tag with validation"""
              try:
                  result = subprocess.run(
                      ['git', 'describe', '--tags', '--abbrev=0'],
                      capture_output=True,
                      text=True,
                      check=True,
                      timeout=10
                  )
                  tag = result.stdout.strip()
                  
                  # Validate tag format (semver)
                  if not re.match(r'^v?\d+\.\d+\.\d+(-[a-zA-Z0-9.]+)?$', tag):
                      print(f"âš ï¸ Tag '{tag}' doesn't follow semver format")
                      print(f"   Expected format: v1.2.3 or v1.2.3-beta.1")
                  
                  return tag
              except subprocess.TimeoutExpired:
                  print("âŒ Git command timed out")
                  return None
              except subprocess.CalledProcessError as e:
                  print(f"âš ï¸ No tags found: {e.stderr}")
                  return None
              except Exception as e:
                  log_error("get_latest_tag", e)
                  raise

          def get_previous_tag(current_tag):
              """Get the tag before current_tag"""
              try:
                  result = subprocess.run(
                      ['git', 'tag', '--sort=-version:refname'],
                      capture_output=True,
                      text=True,
                      check=True,
                      timeout=10
                  )
                  tags = result.stdout.strip().split('\n')
                  
                  # Validate current_tag exists in list
                  try:
                      current_index = tags.index(current_tag)
                  except ValueError:
                      print(f"âš ï¸ Current tag '{current_tag}' not found in tag list")
                      return None
                  
                  if current_index + 1 < len(tags):
                      return tags[current_index + 1]
                  return None
                  
              except subprocess.TimeoutExpired:
                  print("âŒ Git tag command timed out")
                  return None
              except subprocess.CalledProcessError as e:
                  print(f"âŒ Git tag command failed: {e.stderr}")
                  return None
              except Exception as e:
                  log_error("get_previous_tag", e)
                  raise

          def get_commits_between(from_ref, to_ref):
              """Get commits between two refs with validation"""
              if from_ref:
                  cmd = ['git', 'log', f'{from_ref}..{to_ref}', 
                         '--pretty=format:%H|%s|%an|%ad', '--date=short']
              else:
                  cmd = ['git', 'log', to_ref, 
                         '--pretty=format:%H|%s|%an|%ad', '--date=short']
              
              try:
                  result = subprocess.run(
                      cmd,
                      capture_output=True,
                      text=True,
                      check=True,
                      timeout=30
                  )
              except subprocess.TimeoutExpired:
                  print("âŒ Git log command timed out")
                  return []
              except subprocess.CalledProcessError as e:
                  print(f"âŒ Git log failed: {e.stderr}")
                  return []
              
              commits = []
              for line_num, line in enumerate(result.stdout.strip().split('\n'), 1):
                  if not line:
                      continue
                  
                  # Validate line format before parsing
                  parts = line.split('|', 3)
                  if len(parts) != 4:
                      print(f"âš ï¸ Skipping malformed commit on line {line_num}")
                      print(f"   Expected 4 parts, got {len(parts)}: {line[:80]}...")
                      continue
                  
                  hash, subject, author, date = parts
                  
                  # Validate hash format
                  if not re.match(r'^[0-9a-f]{40}$', hash):
                      print(f"âš ï¸ Skipping commit with invalid hash: {hash[:20]}...")
                      continue
                  
                  commits.append({
                      'hash': hash[:12],  # Use 12 characters for better uniqueness
                      'subject': subject,
                      'author': author,
                      'date': date
                  })
              
              return commits

          def categorize_commits(commits):
              """Categorize commits by conventional commit type"""
              categories = defaultdict(list)
              seen_hashes = set()
              
              for commit in commits:
                  # Prevent duplicates
                  if commit['hash'] in seen_hashes:
                      continue
                  seen_hashes.add(commit['hash'])
                  
                  subject = commit['subject']
                  
                  # Parse conventional commit format with breaking change support
                  match = re.match(r'^(\w+)(\(.+\))?(!)?:\s*(.+)$', subject)
                  if match:
                      type_name = match.group(1).lower()
                      scope = match.group(2)
                      is_breaking = match.group(3) == '!'
                      description = match.group(4)
                      
                      # Prioritize breaking changes
                      if is_breaking:
                          categories['âš ï¸ BREAKING CHANGES'].append({**commit, 'description': description})
                      elif type_name in ['feat', 'feature']:
                          categories['Features'].append({**commit, 'description': description})
                      elif type_name == 'fix':
                          categories['Bug Fixes'].append({**commit, 'description': description})
                      elif type_name in ['docs', 'doc']:
                          categories['Documentation'].append({**commit, 'description': description})
                      elif type_name in ['style', 'refactor', 'perf']:
                          categories['Improvements'].append({**commit, 'description': description})
                      elif type_name in ['test', 'tests']:
                          categories['Tests'].append({**commit, 'description': description})
                      elif type_name in ['chore', 'ci', 'build']:
                          categories['Maintenance'].append({**commit, 'description': description})
                      else:
                          categories['Other'].append({**commit, 'description': description})
                  else:
                      # Non-conventional commit
                      categories['Other'].append({**commit, 'description': subject})
              
              return categories

          def generate_changelog_content(tag, date, categories):
              """Generate changelog markdown for a version"""
              lines = [f"## [{tag}] - {date}\n"]
              
              # Order of categories (breaking changes first)
              category_order = ['âš ï¸ BREAKING CHANGES', 'Features', 'Bug Fixes', 'Documentation', 
                               'Improvements', 'Tests', 'Maintenance', 'Other']
              
              for category in category_order:
                  if category in categories and categories[category]:
                      lines.append(f"\n### {category}\n")
                      for commit in categories[category]:
                          desc = commit.get('description', commit['subject'])
                          lines.append(f"- {desc} ([{commit['hash']}](https://github.com/${{{{ github.repository }}}}/commit/{commit['hash']}))".replace('${{{{ github.repository }}}}', 'LuisSambrano/antigravity-skills'))
              
              lines.append("\n")
              return '\n'.join(lines)

          # Main execution
          print("ðŸ” Detecting latest tag...")
          latest_tag = get_latest_tag()

          if not latest_tag:
              print("âš ï¸ No tags found. Creating initial CHANGELOG.md")
              with open('CHANGELOG.md', 'w') as f:
                  f.write("# Changelog\n\n")
                  f.write("All notable changes to this project will be documented in this file.\n\n")
                  f.write("The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n")
                  f.write("and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n")
              print("âœ… Created initial CHANGELOG.md")
              sys.exit(0)

          print(f"ðŸ“Œ Latest tag: {latest_tag}")

          previous_tag = get_previous_tag(latest_tag)
          if previous_tag:
              print(f"ðŸ“Œ Previous tag: {previous_tag}")
          else:
              print("ðŸ“Œ No previous tag found (first release)")

          # Get commits
          print("ðŸ“ Fetching commits...")
          commits = get_commits_between(previous_tag, latest_tag)
          print(f"   Found {len(commits)} commits")

          if not commits:
              print("âš ï¸ No commits found between tags")
              sys.exit(0)

          # Categorize commits
          categories = categorize_commits(commits)

          # Generate changelog entry
          today = datetime.now().strftime('%Y-%m-%d')
          new_entry = generate_changelog_content(latest_tag, today, categories)

          # Read existing changelog or create header
          try:
              with open('CHANGELOG.md', 'r') as f:
                  existing_content = f.read()
          except FileNotFoundError:
              existing_content = "# Changelog\n\n"
              existing_content += "All notable changes to this project will be documented in this file.\n\n"
              existing_content += "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n"
              existing_content += "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n"

          # Check if this version already exists
          if f"## [{latest_tag}]" in existing_content:
              print(f"âš ï¸ Version {latest_tag} already exists in CHANGELOG.md")
              sys.exit(0)

          # Insert new entry after header
          header_end = existing_content.find('\n\n## ')
          if header_end == -1:
              # No previous entries
              new_content = existing_content + new_entry
          else:
              # Insert before first entry
              new_content = existing_content[:header_end + 2] + new_entry + existing_content[header_end + 2:]

          # Write updated changelog
          with open('CHANGELOG.md', 'w') as f:
              f.write(new_content)

          print(f"âœ… Updated CHANGELOG.md with version {latest_tag}")
          print(f"\nðŸ“Š Summary:")
          for category, items in categories.items():
              if items:
                  print(f"   - {category}: {len(items)}")
          PYTHON_SCRIPT

      - name: Commit and push CHANGELOG
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet CHANGELOG.md; then
            echo "â„¹ï¸ No changes to CHANGELOG.md"
            exit 0
          fi

          # Validate tag format before commit
          TAG=$(git describe --tags --abbrev=0)
          if [[ ! "$TAG" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            echo "âŒ Invalid tag format: $TAG"
            exit 1
          fi

          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG for $TAG [skip ci]"

          # Check push exit code
          if git push; then
            echo "âœ… CHANGELOG.md updated and pushed successfully"
          else
            EXIT_CODE=$?
            echo "âŒ Failed to push CHANGELOG.md (exit code: $EXIT_CODE)"
            echo "This might be due to:"
            echo "  - Protected branch requiring PR"
            echo "  - Insufficient permissions"
            echo "  - Network failure"
            exit 1
          fi

      - name: Create summary
        if: always()
        run: |
          echo "## ðŸ“ Changelog Generation Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f CHANGELOG.md ]; then
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "unknown")
            echo "**Version**: $TAG" >> $GITHUB_STEP_SUMMARY
            echo "**Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ job.status }}" == "success" ]; then
              echo "âœ… The CHANGELOG.md has been successfully updated." >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ Changelog generation failed. Check logs for details." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ CHANGELOG.md not found" >> $GITHUB_STEP_SUMMARY
          fi
